#include <stdio.h>
#include <stdlib.h>
#include <complex>
#include<omp.h>
#include<time.h>
using namespace std;

#define width_size      800
#define height_size     600
#define Maxval          255

static const float orig_x = width_size * 2 / 3;
static const float orig_y = height_size * 1 / 2;

typedef struct _pixel {
    unsigned char r;
    unsigned char g;
    unsigned char b;
} pixel;

static const pixel dim_gray = { 105, 105, 105 };

static unsigned char iteration(int x, int y)
{
    const int limit = Maxval + 1;
    int i;
    complex<float> c((x - orig_x) / (width_size / 3), (orig_y - y) / (height_size / 2));
    complex<float> z(0, 0);

    for (i = 0; i < limit; i++) {
        /* basic formula */
        z = z * z + c;
        if (z.real() > 2 || z.imag() > 2)
            break;
    }
    return (unsigned char)(i == limit ? 0 : i);
}


int main(int argc, char* argv[])
{
    FILE* f = fopen("mandelbrot.ppm", "wb");
    int start, end, thread_count = strtol(argv[1], NULL, 10);
    //int pixelArray[height_size][width_size][3];
    //pixel pixelArray[height_size][width_size];
    pixel** pixelArray = new pixel * [height_size];
    for (int i = 0; i < height_size; i++)
    {
        pixelArray[i] = new pixel[width_size];
    }

    //memset(pixelArray, 0, height_size * width_size * sizeof(pixel));
    /* PPM header */
    fprintf(f,
        "P6\n"      /* PPM magic number */
        "#Mandelbrot Set\n"
        "%d "       /* width, in ASCII decimal */
        "%d\n"      /* height, in ASCII decimal */
        "%d\n",     /* maximum color value, in ASCII decimal */
        width_size, height_size, Maxval);
    start = clock();
    /* Write every pixel generated by Mandelbrot Set */
#		pragma omp parallel for num_threads(thread_count)
    for (int i = 0; i < height_size; i++) {
        for (int j = 0; j < width_size; j++) {
            unsigned char iter = iteration(j, i);
            if (iter) {
                //pixel p = {iter,(float)abs(j - orig_x) / width_size * Maxval,(float)abs(i - orig_y) / height_size * Maxval };
                pixelArray[i][j].r = iter;
                pixelArray[i][j].g = (float)abs(j - orig_x) / width_size * Maxval;
                pixelArray[i][j].b = (float)abs(i - orig_y) / height_size * Maxval;
                //fwrite(&p, sizeof(pixel), 1, f);
            }
            else {
                pixelArray[i][j].r = dim_gray.r;
                pixelArray[i][j].g = dim_gray.g;
                pixelArray[i][j].b = dim_gray.b;
                //fwrite(&dim_gray, sizeof(pixel), 1, f);
            }
        }
    }

    for (int i = 0; i < height_size; i++)
    {
        for (int j = 0; j < width_size; j++)
        {
            fwrite(&(pixelArray[i][j]), sizeof(pixel), 1, f);
        }
    }
    end = clock();
    printf("Total time = %d ms\n", end - start);
    fclose(f);
    return 0;
}